-- spi_master.vhd
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity spi_master is
  generic(
    CLK_DIV : positive := 10  -- 200 MHz / (2*10) = 10 MHz SCLK
  );
  port(
    clk       : in  std_logic;
    rst_n     : in  std_logic;

    -- Command interface
    start     : in  std_logic;
    nbytes    : in  unsigned(7 downto 0);   -- kaç byte gönderilecek
    tx_data   : in  std_logic_vector(8*16-1 downto 0); -- max 16 byte paket
    rx_data   : out std_logic_vector(8*16-1 downto 0);
    busy      : out std_logic;
    done      : out std_logic;

    -- SPI pins (Mode-0)
    sclk      : out std_logic;
    cs_n      : out std_logic;
    mosi      : out std_logic;
    miso      : in  std_logic
  );
end entity;

architecture rtl of spi_master is
  type state_t is (IDLE, ASSERT_CS, SHIFT, DEASSERT_CS, DONE);
  signal state    : state_t := IDLE;

  signal div_cnt  : unsigned(15 downto 0) := (others=>'0');
  signal sclk_i   : std_logic := '0';
  signal sclk_en  : std_logic := '0';

  signal bit_cnt  : integer range 0 to 7 := 7;
  signal byte_idx : integer range 0 to 15 := 0;
  signal nbytes_i : integer range 0 to 255 := 0;

  signal tx_mat   : std_logic_vector(8*16-1 downto 0);
  signal rx_mat   : std_logic_vector(8*16-1 downto 0);

begin
  sclk <= sclk_i when sclk_en='1' else '0';
  cs_n <= '1' when state=IDLE or state=DONE else '0';
  busy <= '1' when state/=IDLE and state/=DONE else '0';
  done <= '1' when state=DONE else '0';
  rx_data <= rx_mat;

  -- clock divider
  process(clk)
  begin
    if rising_edge(clk) then
      if rst_n='0' then
        div_cnt <= (others=>'0');
        sclk_i  <= '0';
      elsif sclk_en='1' then
        if div_cnt = to_unsigned(CLK_DIV-1, div_cnt'length) then
          div_cnt <= (others=>'0');
          sclk_i  <= not sclk_i;
        else
          div_cnt <= div_cnt + 1;
        end if;
      else
        div_cnt <= (others=>'0');
        sclk_i  <= '0';
      end if;
    end if;
  end process;

  -- shift engine (Mode-0: MOSI değişimi sclk düşüşte, MISO örnekleme yükselişte)
  process(clk)
  begin
    if rising_edge(clk) then
      if rst_n='0' then
        state <= IDLE;
        sclk_en <= '0';
        bit_cnt <= 7;
        byte_idx <= 0;
        nbytes_i <= 0;
        tx_mat <= (others=>'0');
        rx_mat <= (others=>'0');
      else
        case state is
          when IDLE =>
            if start='1' then
              tx_mat   <= tx_data;
              nbytes_i <= to_integer(nbytes);
              byte_idx <= 0;
              bit_cnt  <= 7;
              sclk_en  <= '1';
              state    <= ASSERT_CS;
            end if;

          when ASSERT_CS =>
            -- bir yarım period bekleyip shift'e geç
            if sclk_i='1' then  -- ilk toggle
              state <= SHIFT;
            end if;

          when SHIFT =>
            -- düşen kenarda MOSI güncelle
            if sclk_i='0' and div_cnt = to_unsigned(CLK_DIV-1, div_cnt'length) then
              -- MSB first
              mosi <= tx_mat(8*16-1 - byte_idx*8 - (7-bit_cnt));
            end if;

            -- yükselen kenarda MISO örnekle
            if sclk_i='1' and div_cnt = to_unsigned(CLK_DIV-1, div_cnt'length) then
              rx_mat(8*16-1 - byte_idx*8 - (7-bit_cnt)) <= miso;
              if bit_cnt=0 then
                bit_cnt <= 7;
                if byte_idx = nbytes_i-1 then
                  state <= DEASSERT_CS;
                else
                  byte_idx <= byte_idx + 1;
                end if;
              else
                bit_cnt <= bit_cnt - 1;
              end if;
            end if;

          when DEASSERT_CS =>
            sclk_en <= '0';
            state   <= DONE;

          when DONE =>
            state <= IDLE;
        end case;
      end if;
    end if;
  end process;

end architecture;
-- ad3552r_ctrl.vhd
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity ad3552r_ctrl is
  generic(
    SYS_CLK_HZ : natural := 200_000_000;
    SCLK_DIV   : positive := 10  -- SPI master CLK_DIV
  );
  port(
    clk        : in  std_logic;
    rst_n      : in  std_logic;

    -- Kullanıcı arayüzü: CH0 kod yaz
    set_code   : in  std_logic;
    code_ch0   : in  unsigned(15 downto 0);

    -- AD3552R pinleri
    spi_sclk   : out std_logic;
    spi_cs_n   : out std_logic;
    spi_mosi   : out std_logic;
    spi_miso   : in  std_logic;
    ad_reset_n : out std_logic;  -- aktif düşük, sürekli '1' tutacağız
    ad_ldac_n  : out std_logic;  -- ister hep 0, ister yazılımsal tetikle
    ad_alert_n : in  std_logic;

    -- Durum
    ready      : out std_logic
  );
end entity;

architecture rtl of ad3552r_ctrl is
  component spi_master
    generic(CLK_DIV : positive := 10);
    port(
      clk, rst_n : in std_logic;
      start      : in std_logic;
      nbytes     : in unsigned(7 downto 0);
      tx_data    : in std_logic_vector(8*16-1 downto 0);
      rx_data    : out std_logic_vector(8*16-1 downto 0);
      busy, done : out std_logic;
      sclk, cs_n, mosi : out std_logic;
      miso : in std_logic
    );
  end component;

  type state_t is (
    ST_WAIT_PWR, ST_CLR_ERR, ST_PWRDN_CFG, ST_RANGE, ST_IDLE,
    ST_WR_CODE, ST_SW_LDAC
  );
  signal st        : state_t := ST_WAIT_PWR;

  constant WAIT_100MS : natural := (SYS_CLK_HZ / 10); -- 100 ms
  signal wait_cnt  : natural range 0 to WAIT_100MS := 0;

  -- spi interface
  signal spi_start : std_logic := '0';
  signal spi_busy  : std_logic;
  signal spi_done  : std_logic;
  signal spi_tx    : std_logic_vector(8*16-1 downto 0) := (others=>'0');
  signal spi_rx    : std_logic_vector(8*16-1 downto 0);
  signal spi_nbytes: unsigned(7 downto 0) := (others=>'0');

  -- yardımcı
  procedure spi_write_1byte(addr : in std_logic_vector(7 downto 0);
                            data : in std_logic_vector(7 downto 0)) is
  begin
    spi_tx     <= (others=>'0');
    -- Instruction byte: [7]=R/W(0=write), [6:0]=addr(7-bit)
    spi_tx(8*16-1 downto 8*15) <= addr;  -- 1. byte = addr (R/W=0 varsayıyoruz)
    spi_tx(8*15-1 downto 8*14) <= data;  -- 2. byte = data
    spi_nbytes <= to_unsigned(2,8);
    spi_start  <= '1';
  end procedure;

  procedure spi_write_2byte(addr  : in std_logic_vector(7 downto 0);
                            data16: in std_logic_vector(15 downto 0)) is
  begin
    spi_tx     <= (others=>'0');
    spi_tx(8*16-1 downto 8*15) <= addr;
    spi_tx(8*15-1 downto 8*14) <= data16(15 downto 8); -- MSB
    spi_tx(8*14-1 downto 8*13) <= data16(7 downto 0);  -- LSB
    spi_nbytes <= to_unsigned(3,8);
    spi_start  <= '1';
  end procedure;

  signal latched_code : unsigned(15 downto 0) := (others=>'0');

begin
  -- pin varsayılanları
  ad_reset_n <= '1';     -- harici reset kullanmıyoruz
  ad_ldac_n  <= '1';     -- yazılımsal LDAC kullanacağız
  ready      <= '1' when st=ST_IDLE else '0';

  -- SPI master inst
  u_spi: spi_master
    generic map(CLK_DIV => SCLK_DIV)
    port map(
      clk=>clk, rst_n=>rst_n,
      start=>spi_start, nbytes=>spi_nbytes,
      tx_data=>spi_tx, rx_data=>spi_rx,
      busy=>spi_busy, done=>spi_done,
      sclk=>spi_sclk, cs_n=>spi_cs_n,
      mosi=>spi_mosi, miso=>spi_miso
    );

  -- kontrol FSM
  process(clk)
  begin
    if rising_edge(clk) then
      spi_start <= '0';
      if rst_n='0' then
        st <= ST_WAIT_PWR;
        wait_cnt <= 0;
      else
        case st is
          when ST_WAIT_PWR =>
            -- datasheet: power-up sonrası ~100 ms beklemek güvenli
            if wait_cnt < WAIT_100MS then
              wait_cnt <= wait_cnt + 1;
            else
              st <= ST_CLR_ERR;
            end if;

          when ST_CLR_ERR =>
            -- ERR_STATUS (0x17), bit0=1 yazarak reset durumunu temizle
            if spi_done='1' then
              st <= ST_PWRDN_CFG;
            elsif spi_busy='0' then
              spi_write_1byte(x"17", "00000001"); -- R/W=0 + addr=0x17, data=0x01
            end if;

          when ST_PWRDN_CFG =>
            -- POWERDOWN_CONFIG (0x18)=0x00 (kanallar aktif)
            if spi_done='1' then
              st <= ST_RANGE;
            elsif spi_busy='0' then
              spi_write_1byte(x"18", x"00");
            end if;

          when ST_RANGE =>
            -- CH0_CH1_OUTPUT_RANGE (0x19) = 0x11 (CH1=001, CH0=001)
            if spi_done='1' then
              st <= ST_IDLE;
            elsif spi_busy='0' then
              spi_write_1byte(x"19", x"11");
            end if;

          when ST_IDLE =>
            if set_code='1' then
              latched_code <= code_ch0;
              st <= ST_WR_CODE;
            end if;

          when ST_WR_CODE =>
            -- CH0_INPUT_16B (0x33) = code
            if spi_done='1' then
              st <= ST_SW_LDAC;
            elsif spi_busy='0' then
              spi_write_2byte(x"33", std_logic_vector(latched_code));
            end if;

          when ST_SW_LDAC =>
            -- SW_LDAC_16B (0x32): bit0=1 -> CH0 load
            if spi_done='1' then
              st <= ST_IDLE;
            elsif spi_busy='0' then
              spi_write_1byte(x"32", "00000001");
            end if;

        end case;
      end if;
    end if;
  end process;

end architecture;
-- top.vhd
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity top is
  port(
    sys_clk    : in  std_logic;  -- 200 MHz
    sys_rst_n  : in  std_logic;

    -- FMC pins
    spi_sclk   : out std_logic;
    spi_cs_n   : out std_logic;
    spi_mosi   : out std_logic;
    spi_miso   : in  std_logic;
    ad_reset_n : out std_logic;
    ad_ldac_n  : out std_logic;
    ad_alert_n : in  std_logic
  );
end entity;

architecture rtl of top is
  signal set_code  : std_logic := '0';
  signal code_ch0  : unsigned(15 downto 0) := (others=>'0');
  signal ready     : std_logic;

  -- basit zamanlayıcı
  signal cnt : unsigned(23 downto 0) := (others=>'0');

begin
  u_dac: entity work.ad3552r_ctrl
    generic map(
      SYS_CLK_HZ => 200_000_000,
      SCLK_DIV   => 10
    )
    port map(
      clk=>sys_clk, rst_n=>sys_rst_n,
      set_code=>set_code, code_ch0=>code_ch0,
      spi_sclk=>spi_sclk, spi_cs_n=>spi_cs_n, spi_mosi=>spi_mosi, spi_miso=>spi_miso,
      ad_reset_n=>ad_reset_n, ad_ldac_n=>ad_ldac_n, ad_alert_n=>ad_alert_n,
      ready=>ready
    );

  -- Örnek: 0..5 V arasında ~10 Hz ramp
  process(sys_clk)
  begin
    if rising_edge(sys_clk) then
      if sys_rst_n='0' then
        cnt <= (others=>'0');
        set_code <= '0';
      else
        cnt <= cnt + 1;
        if ready='1' and cnt = 0 then
          code_ch0 <= code_ch0 + to_unsigned(1024,16); -- ~ adım
          set_code <= '1';
        else
          set_code <= '0';
        end if;
      end if;
    end if;
  end process;

end architecture;
-- tb_top.vhd
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity tb_top is
end entity;

architecture sim of tb_top is
  -- DUT ports
  signal sys_clk    : std_logic := '0';
  signal sys_rst_n  : std_logic := '0';

  signal spi_sclk   : std_logic;
  signal spi_cs_n   : std_logic;
  signal spi_mosi   : std_logic;
  signal spi_miso   : std_logic := '0';  -- DAC’tan okuma yapmıyoruz, sabit 0
  signal ad_reset_n : std_logic;
  signal ad_ldac_n  : std_logic;
  signal ad_alert_n : std_logic := '1';  -- ALERT normalde 1

  -- sim parametreleri
  constant CLK_PERIOD : time := 5 ns;  -- 200 MHz clock (5 ns period)

begin
  -- Clock generation
  clk_process : process
  begin
    sys_clk <= '0';
    wait for CLK_PERIOD/2;
    sys_clk <= '1';
    wait for CLK_PERIOD/2;
  end process;

  -- Reset generation
  rst_process : process
  begin
    sys_rst_n <= '0';
    wait for 200 ns;      -- 200 ns reset low
    sys_rst_n <= '1';
    wait;
  end process;

  -- DUT instance
  uut: entity work.top
    port map(
      sys_clk    => sys_clk,
      sys_rst_n  => sys_rst_n,
      spi_sclk   => spi_sclk,
      spi_cs_n   => spi_cs_n,
      spi_mosi   => spi_mosi,
      spi_miso   => spi_miso,
      ad_reset_n => ad_reset_n,
      ad_ldac_n  => ad_ldac_n,
      ad_alert_n => ad_alert_n
    );

  -- Monitoring process
  monitor : process
  begin
    wait until rising_edge(sys_clk);
    if sys_rst_n = '1' then
      report "SPI_CS=" & std_logic'image(spi_cs_n) &
             " SPI_SCLK=" & std_logic'image(spi_sclk) &
             " MOSI=" & std_logic'image(spi_mosi);
    end if;
  end process;

end architecture;
## System clock (200 MHz KC705 osilatör)
create_clock -name sysclk -period 5.000 [get_ports sys_clk]

## IO standardları (FMC LVCMOS18 çalışıyor)
set_property IOSTANDARD LVCMOS18 [get_ports {spi_sclk spi_cs_n spi_mosi spi_miso ad_reset_n ad_ldac_n ad_alert_n}]

## Pin mapping (örnek – kesin FMC tablosundan doldur)
set_property PACKAGE_PIN Y23 [get_ports spi_sclk]     ; # FMC LA00_CC_P
set_property PACKAGE_PIN AA23 [get_ports spi_cs_n]    ; # FMC LA00_CC_N
set_property PACKAGE_PIN W21 [get_ports spi_mosi]     ; # FMC LA01_P
set_property PACKAGE_PIN V21 [get_ports spi_miso]     ; # FMC LA01_N
set_property PACKAGE_PIN AB20 [get_ports ad_reset_n]  ; # FMC LA02_P
set_property PACKAGE_PIN AC20 [get_ports ad_ldac_n]   ; # FMC LA02_N
set_property PACKAGE_PIN Y20 [get_ports ad_alert_n]   ; # FMC LA03_P
